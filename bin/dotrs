#!/usr/bin/env ruby
# frozen_string_literal: true

require 'git'
require 'optparse'
require_relative '../lib/master_tree'
require_relative '../lib/version.rb'

EXIT_SUCCESS = 0
EXIT_FAILURE = 1

REPO_PATH = File.join(Dir.home, '.dotfiles')

# Set up the options
optparse = OptionParser.new do |opts|
  opts.banner = "Usage: dotrs COMMAND\n\n"                                     \
                "Straightforward dotfiles management\n\n"                      \
                "Commands:\n"                                                  \
                "\tadd FILE...\t\tAdd FILE to the tracked files\n"             \
                "\tapply\t\t\tLink all tracked files to their real location\n" \
                "\tinit REMOTE\t\tClone the REMOTE repository\n"               \
                "\tlist\t\t\tList all currently tracked files\n"               \
                "\tremove FILE...\t\tRemove FILE from being tracked\n"         \
                "\tpull\t\t\tPull the latest changes\n"                        \
                "\tpush\t\t\tPush local changes\n"                             \
                "Options:\n"
  opts.on('--help', 'Display this help and exit') do
    puts opts
    exit(EXIT_SUCCESS)
  end
  opts.on('--version', 'Display version number and exit') do
    puts "dotrs #{Dotrs::VERSION}"
    exit(EXIT_SUCCESS)
  end
end

# Parse and check for invalid options
begin
  optparse.parse!
rescue OptionParser::InvalidOption
  puts('dotrs: invalid option.')
  puts('Type `dotrs --help` for a list of available commands.')
  exit(1)
end

# Check if a command has been given
if ARGV.empty?
  puts('dotrs: no command given.')
  puts('Type `dotrs --help` for a list of available commands.')
  exit(EXIT_FAILURE)
end

# Get the command given by the user
cmd = ARGV[0].to_sym

# Handle the init command
if cmd == :init
  begin
    Git.clone(ARGV[1], REPO_PATH)
  rescue Git::GitExecuteError
    puts('dotrs: an error occured while cloning.')
    exit(EXIT_FAILURE)
  end
  exit(EXIT_SUCCESS)
end

# Exit if REPO_PATH doesn't exist
unless Dir.exist?(REPO_PATH)
  puts('dotrs: not initialized')
  puts('Type `dotrs --help` for a list of available commands.')
  exit(EXIT_FAILURE)
end

# Handle other commands
begin
  mt = MasterTree.new(REPO_PATH, Dir.home)
  repo = Git.open(REPO_PATH)
  case cmd
  when :add
    ARGV[1..-1].each do |file|
      begin
        mt.add(file)
      rescue AssertionError
        puts("dotrs: invalid file '#{file}'.")
        puts('The file can\'t be a symbolic link.')
        exit(EXIT_FAILURE)
      end
    end
  when :apply
    mt.link_all
  when :list
    mt.list.each { |file| puts(file) }
  when :remove
    ARGV[1..-1].each { |file| mt.remove(file) }
  when :pull
    repo.pull
  when :push
    repo.add(all: true)
    repo.commit('sync')
    repo.push
  else
    puts("dotrs: unknown command '#{ARGV[0]}'.")
    puts('Type `dotrs --help` for a list of available commands.')
    exit(EXIT_FAILURE)
  end
rescue Interrupt
  puts("\ndotrs: interrupted!")
  exit(EXIT_FAILURE)
end
